---
title: "Dynamics.R"
author: "Paweł Obrępalski"
menu:
  main:
    parent: "Material"
    weight: 0
date: 2015-07-23T21:13:14-05:00
categories: ["R"]
tags: ["TCLB"]
---



<div id="fielddensity" class="section level2">
<h2>Field/Density</h2>
<p><strong>Fields</strong> are variables stored in mesh nodes. It is usually necessary to be able to look into neighbouring value. This needs to be specify during <code>Field</code> declaration, as the code must ‘know’ that we want to access this fields values in neighbours, or otherwise it won’t compile. It can be done by by using <code>dx=c()</code>, where <code>c(..)</code> means vector in R programming language.</p>
<pre class="r"><code>AddField(name=&quot;u&quot;, dx=c(-1,1), dy=c(-1,1))              #2D case
AddField(name=&quot;u&quot;, dx=c(-1,1), dy=c(-1,1), dz=c(-1,1))  #3D case</code></pre>
<p>It can also be done using <code>stencil</code>.</p>
<pre class="r"><code>AddField(name=&quot;u&quot;, stencil2d=1) #2D case
AddField(name=&quot;u&quot;, stencil3d=1) #3D case</code></pre>
<p>This will allow access to neighbours positioned in distance of 1 element. In order to acces further change to <code>c(-2,2)</code> or <code>stencil3d=2</code>.</p>
<p>Values stored in fields can be accessed from <code>Dynamics.c</code> with an offset(<code>field_name(1,1)</code>). If some values are often loaded, the procedure can be optimized using accessors called <strong>Densities</strong> which load corresponding values from a specified field with a predefined offset. Using <code>Density</code> instead of accessing <code>Field</code> ‘manually’ each time will speed up the code, as required values will be loaded into memeory before <code>Run()</code> function.</p>
</div>
<div id="setting" class="section level2">
<h2>Setting</h2>
<p>Settings are variables that can be set in the <code>.xml</code> and accessed by <code>Dynamics.c</code> in all nodes. Settings can be <code>zonal</code>, which means that they can be set to different values in different mesh zones, defined in <code>.xml</code> files. It is also possible to define a default value for a setting, this way even if it is not specified in <code>.xml</code> file code will run without trouble.</p>
<pre class="r"><code>AddSetting(name=&quot;Name&quot;, default = &quot;value&quot;, comment=&quot;some comment&quot;, zonal=TRUE/FALSE )
AddSetting(name=&quot;Velocity&quot;, default=&quot;0m/s&quot;, comment=&#39;Inlet velocity&#39;, zonal=TRUE)</code></pre>
</div>
<div id="qauantity" class="section level2">
<h2>Qauantity</h2>
<p>Values that can be exported to VTK files (and Catalyst), to later analyse in ParaView. In most cases they are macroscopic human-readable quantites like velocity, pressure, displacement etc, but can be also more ‘abstract’ values.</p>
<pre class="r"><code>AddQuantity(name=&quot;Name&quot;, unit=&quot;unit&quot;, comment=&quot;Some comment&quot;, vector = T/F)
AddQuantity(name=&quot;U&quot;, unit=&quot;m/s&quot;, comment=&quot;macroscopic velocity&quot;, vector = T)</code></pre>
<p><code>vector</code> should be set to <code>T</code> for properties like velocity, momentum etc.</p>
<p>In order to extract those values the <code>GetName()</code> function must be defined in <code>Dynamics.c</code>.</p>
<pre class="c"><code>//Example for d2q9_SRT model

CudaDeviceFunction vector_t GetU(){ //The type of the function would be real_t if the Quantity is not a vector
        real_t d = f[8]+f[7]+f[6]+f[5]+f[4]+f[3]+f[2]+f[1]+f[0]; \\Rho(density) is sum of all f[]
        vector_t u;
        // pv = pu + G/2
        u.x = (( f[8]-f[7]-f[6]+f[5]-f[3]+f[1] )/d + GravitationX*0.5 );    //GravitationX/Y are `Settings`, their values are taken from `.xml` file or default from `Dynamics.R` definition.
        u.y = ((-f[8]-f[7]+f[6]+f[5]-f[4]+f[2] )/d + GravitationY*0.5 );
        u.z = 0;      //the model is 2 dimensional
        return u;
}</code></pre>
</div>
<div id="actionstage" class="section level2">
<h2>Action/Stage</h2>
<p><strong>Stages</strong> are specific functions, defined in <code>Dynamics.c</code>, for which it can be defined which <code>Densities</code> will be loaded and which <code>Fields</code> will be saved. They can be defined in <code>Dynamics.R</code></p>
<p><strong>Action</strong> is a series of <code>Stages</code> executed in defined order.</p>
<p>Currently, there are 2 pre-defined <code>Stages</code>(in <code>src/conf.R</code>): <code>BaseIteration</code> and <code>BaseInit</code>. The first one runs the <code>Run()</code> function from <code>Dynamics.c</code>, while the latter runs <code>Init()</code>. There are also 2 pre-defined <code>Actions</code>: <code>Iteration</code>(which runs <code>BaseIteration</code> stage) and <code>Init</code>(which runs <code>BaseInit</code> stage).</p>
<p>Pre-defined <code>Actions/Stages</code> can be easily replaced with user-defined ones, as they won’t be created unless no user-defined functions with those names are found.</p>
<p>To define new <code>Stage</code>:</p>
<pre class="r"><code>AddStage(&quot;BaseIteration&quot;, &quot;Run&quot;, save=Fields$group == &quot;f&quot;, load=DensityAll$group == &quot;f&quot;)
#Creates stage called BaseIterations, which loads all the Densities from group &quot;f&quot;, runs the function Run() from Dynamics.c and saves all Fields from group &quot;f&quot;
AddStage(&quot;CalcRho&quot;, save=&quot;rho&quot;, load=DensityAll$group == &quot;f&quot;)
#Creates stage called CalcRho, which loads all the Densities from group &quot;f&quot;, and saves rho
AddStage(&quot;CalcNu&quot;, save=&quot;nu&quot;, load=FALSE)
#Creates stage called CalcNu, which does not load anything and only saves nu</code></pre>
<p>Note: groups can be assigned to densities on declaration - <code>group=&quot;f&quot;</code></p>
<p>To define new <code>Action</code>:</p>
<pre class="r"><code>AddAction(&quot;Iteration&quot;, c(&quot;BaseIteration&quot;,&quot;CalcRho&quot;,&quot;CalcNu&quot;))
#Creates action called Iteration, which runs  3 stages (in order): BaseIteration, CalcRho, and CalcNu</code></pre>
<p>Custom <code>Actions</code> and <code>Stages</code> are used when information needs to be exchanged between processes/function in specific, other than pre-defined times. An example can be found in <code>kuper</code> models for multiphase flow.(<code>/models/multiphase/d3q19_kuper</code>).</p>
</div>
